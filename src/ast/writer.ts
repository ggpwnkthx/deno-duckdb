// File: src/writer.ts

// Define interfaces to represent Clang AST nodes (simplified)
interface ClangASTNode {
  kind: string;
  name?: string;
  type?: any;
  children?: ClangASTNode[];
  [key: string]: any;
}

// Mapping from C types to TypeScript types for Deno FFI
const typeMap: { [key: string]: string } = {
  "int": "number",
  "float": "number",
  "double": "number",
  "char": "string",
  "void": "void",
  "bool": "boolean",
  // Add more mappings as needed
};

// Helper function to map C types to TypeScript types
function mapCTypeToTS(cType: string): string {
  // Handle pointer types
  if (cType.endsWith("*")) {
    // For simplicity, map pointers to Deno's FFI `Pointer` type
    return "Pointer";
  }

  return typeMap[cType] || "any"; // Default to 'any' if type not found
}

// Function to parse the AST and extract type and function declarations
function parseAST(ast: ClangASTNode): { types: string[]; functions: string[] } {
  const types: string[] = [];
  const functions: string[] = [];

  function traverse(node: ClangASTNode) {
    switch (node.kind) {
      case "TypedefDecl":
        if (node.name && node.type) {
          const cType = getTypeName(node.type);
          types.push(`export type ${node.name} = ${mapCTypeToTS(cType)};`);
        }
        break;

      case "RecordDecl":
        if (node.name) {
          // Assuming it's a struct
          const fields: string[] = [];
          if (node.children) {
            node.children.forEach((child) => {
              if (child.kind === "FieldDecl" && child.name && child.type) {
                const fieldType = getTypeName(child.type);
                fields.push(`  ${child.name}: ${mapCTypeToTS(fieldType)};`);
              }
            });
          }
          const structDef = `export interface ${node.name} {\n${fields.join(
            "\n",
          )}\n}`;
          types.push(structDef);
        }
        break;

      case "FunctionDecl":
        if (node.name && node.type && node.type.kind === "FunctionProto") {
          const returnType = getTypeName(node.type.type);
          const params: string[] = [];
          if (node.type.parameters) {
            node.type.parameters.forEach((param: any) => {
              const paramType = getTypeName(param.type);
              const paramName = param.name || "arg";
              params.push(`${paramName}: ${mapCTypeToTS(paramType)}`);
            });
          }
          const funcDef = `export function ${node.name}(${params.join(
            ", ",
          )}): ${mapCTypeToTS(returnType)};`;
          functions.push(funcDef);
        }
        break;

      default:
        break;
    }

    // Traverse children
    if (node.children && node.children.length > 0) {
      node.children.forEach(traverse);
    }
  }

  traverse(ast);
  return { types, functions };
}

// Helper function to get the type name from a type node
function getTypeName(typeNode: any): string {
  if (typeNode.kind === "PointerType") {
    return getTypeName(typeNode.type) + "*";
  }
  if (typeNode.kind === "BuiltinType") {
    return typeNode.spelling;
  }
  if (typeNode.kind === "RecordType") {
    return typeNode.decl.name;
  }
  if (typeNode.kind === "Typedef") {
    return typeNode.name;
  }
  // Add more cases as needed
  return "void";
}

// Main function
export async function writeTypeScriptFile(ast: ClangASTNode, output_path: string) {
  try {
    const { types, functions } = parseAST(ast);
    const typesFileContent = `// types.ts
// Generated by generate_types.ts

// Import Deno FFI types
import { Pointer } from "https://deno.land/std@0.201.0/ffi/mod.ts";

${types.join("\n\n")}

${functions.join("\n\n")}
`;

    await Deno.writeTextFile(output_path, typesFileContent);
    console.log(`${output_path} has been generated successfully.`);
  } catch (error) {
    console.error(`Error generating ${output_path}:`, error);
    Deno.exit(1);
  }
}
